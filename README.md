# üöÄ TaskListProcessor

[![.NET](https://img.shields.io/badge/.NET-9.0+-512BD4?style=flat-square&logo=dotnet)](https://dotnet.microsoft.com/)
[![License](https://img.shields.io/badge/License-MIT-green.svg?style=flat-square)](LICENSE)
[![Build Status](https://img.shields.io/badge/Build-Passing-brightgreen?style=flat-square)](https://github.com/markhazleton/TaskListProcessor)
[![NuGet](https://img.shields.io/badge/NuGet-Coming%20Soon-orange?style=flat-square)](https://www.nuget.org/packages/TaskListProcessor)

> **A modern, enterprise-grade .NET 9.0 library for orchestrating asynchronous operations with comprehensive telemetry, circuit breakers, dependency injection, and advanced scheduling capabilities.**

---

## üìë Table of Contents

- [üöÄ TaskListProcessor](#-tasklistprocessor)
  - [üìë Table of Contents](#-table-of-contents)
  - [‚ú® Overview](#-overview)
  - [üéØ Why TaskListProcessor?](#-why-tasklistprocessor)
  - [üî• Key Features](#-key-features)
  - [üèóÔ∏è Architecture](#Ô∏è-architecture)
  - [‚ö° Quick Start](#-quick-start)
  - [üìñ Comprehensive Examples](#-comprehensive-examples)
  - [üîß Advanced Usage](#-advanced-usage)
  - [üìä Performance & Telemetry](#-performance--telemetry)
  - [üõ†Ô∏è API Reference](#Ô∏è-api-reference)
  - [üß™ Testing](#-testing)
  - [üîÑ Migration Guide](#-migration-guide)
  - [üèóÔ∏è Project Structure](#Ô∏è-project-structure)
  - [ü§ù Contributing](#-contributing)
  - [üìú License](#-license)
  - [üîó Resources](#-resources)

---

## ‚ú® Overview

TaskListProcessor is a production-ready .NET 9.0 library designed to solve complex asynchronous orchestration challenges in modern applications. Built with enterprise-grade patterns including dependency injection, circuit breakers, task scheduling, and comprehensive telemetry, it provides a robust foundation for high-throughput, fault-tolerant systems.

### üéØ Why TaskListProcessor?

**The Problem:** Modern applications require sophisticated coordination of multiple async operations‚ÄîAPI calls, database queries, file I/O, microservice interactions‚Äîwhile maintaining resilience, observability, and performance under varying loads.

**The Solution:** TaskListProcessor provides a battle-tested, enterprise-ready framework with:

- üõ°Ô∏è **Fault Isolation**: Circuit breakers and individual task failure isolation
- üìä **Enterprise Observability**: OpenTelemetry integration with rich metrics and tracing
- ‚ö° **Advanced Scheduling**: Priority-based, dependency-aware task execution
- üéØ **Type Safety**: Strongly-typed results with comprehensive error categorization
- üîß **Dependency Injection**: Native .NET DI integration with decorator pattern support
- üèóÔ∏è **Interface Segregation**: Clean, focused interfaces following SOLID principles

## üî• Key Features

### Core Processing Capabilities

- **üöÄ Concurrent Execution**: Parallel task processing with configurable concurrency limits and load balancing
- **üõ°Ô∏è Circuit Breaker Pattern**: Automatic failure detection and cascading failure prevention
- **üìä Rich Telemetry**: Comprehensive timing, success rates, error tracking, and OpenTelemetry integration
- **üéØ Type Safety**: Strongly-typed results with full IntelliSense support and error categorization
- **‚è±Ô∏è Timeout & Cancellation**: Built-in support for graceful shutdown and per-task timeouts
- **üîÑ Task Dependencies**: Dependency resolution with topological sorting and execution ordering

### Enterprise Architecture Features

- **üèóÔ∏è Dependency Injection**: Native .NET DI integration with fluent configuration API
- **üé® Interface Segregation**: Clean, focused interfaces following SOLID principles
- **ÔøΩ Decorator Pattern**: Pluggable cross-cutting concerns (logging, metrics, circuit breakers)
- **üìà Advanced Scheduling**: Priority-based, FIFO, LIFO, and custom scheduling strategies
- **üßµ Thread Safety**: Lock-free concurrent collections and thread-safe operations
- **üíæ Memory Optimization**: Object pooling and efficient memory management

### Developer Experience

- **ÔøΩ Structured Logging**: Integration with Microsoft.Extensions.Logging and Serilog
- **üîç Health Checks**: Built-in health monitoring and diagnostic capabilities
- **ÔøΩ Streaming Results**: Async enumerable support for real-time result processing
- **üß™ Testing Support**: Comprehensive test helpers and mock-friendly interfaces
- **üìñ Rich Documentation**: Extensive XML documentation and practical examples

## üèóÔ∏è Architecture

TaskListProcessor implements a modern, enterprise-ready architecture with clear separation of concerns:

```ascii
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Dependency Injection Layer                  ‚îÇ
‚îÇ        services.AddTaskListProcessor().WithAllDecorators()     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      Decorator Chain                            ‚îÇ
‚îÇ  LoggingDecorator ‚Üí MetricsDecorator ‚Üí CircuitBreakerDecorator  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Interface Segregation Layer                 ‚îÇ
‚îÇ  ITaskProcessor ‚îÇ ITaskBatchProcessor ‚îÇ ITaskStreamProcessor   ‚îÇ
‚îÇ              ITaskTelemetryProvider                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Core Processing Engine                       ‚îÇ
‚îÇ            TaskListProcessorEnhanced (Backward Compatible)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ                 ‚îÇ                 ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ TaskDefinition   ‚îÇ ‚îÇTaskTelemetry‚îÇ ‚îÇTaskProgress  ‚îÇ
    ‚îÇ + Dependencies   ‚îÇ ‚îÇ + Metrics   ‚îÇ ‚îÇ + Reporting  ‚îÇ
    ‚îÇ + Priority       ‚îÇ ‚îÇ + Tracing   ‚îÇ ‚îÇ + Streaming  ‚îÇ
    ‚îÇ + Scheduling     ‚îÇ ‚îÇ + Health    ‚îÇ ‚îÇ + Estimates  ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Core Components

- **Interface Layer**: Clean, focused interfaces for different processing scenarios
- **Decorator Layer**: Cross-cutting concerns (logging, metrics, circuit breakers)
- **Processing Engine**: Thread-safe orchestration with advanced scheduling
- **Telemetry System**: Comprehensive observability and health monitoring
- **Dependency Resolution**: Topological sorting and execution ordering
- **Circuit Breaker**: Cascading failure prevention and automatic recovery

## ‚ö° Quick Start

### Installation

```bash
# Clone the repository
git clone https://github.com/markhazleton/TaskListProcessor.git
cd TaskListProcessor

# Build the solution
dotnet build

# Run the demo
dotnet run --project examples/TaskListProcessor.Console
```

### Basic Usage (Direct Instantiation)

```csharp
using TaskListProcessing.Core;
using Microsoft.Extensions.Logging;

// Set up logging (optional but recommended)
using var loggerFactory = LoggerFactory.Create(builder => builder.AddConsole());
var logger = loggerFactory.CreateLogger<Program>();

// Create the processor
using var processor = new TaskListProcessorEnhanced("My Tasks", logger);

// Define your tasks using the factory pattern
var taskFactories = new Dictionary<string, Func<CancellationToken, Task<object?>>>
{
    ["Weather Data"] = async ct => await GetWeatherAsync("London"),
    ["Stock Prices"] = async ct => await GetStockPricesAsync("MSFT"),
    ["User Data"] = async ct => await GetUserDataAsync(userId)
};

// Execute all tasks concurrently
await processor.ProcessTasksAsync(taskFactories, cancellationToken);

// Access results and telemetry
foreach (var result in processor.TaskResults)
{
    Console.WriteLine($"{result.Name}: {(result.IsSuccessful ? "‚úÖ" : "‚ùå")}");
}
```

### Dependency Injection Usage (Recommended)

```csharp
using TaskListProcessing.Extensions;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

// Program.cs
var builder = Host.CreateApplicationBuilder(args);

// Configure TaskListProcessor with decorators
builder.Services.AddTaskListProcessor(options =>
{
    options.MaxConcurrentTasks = 10;
    options.EnableDetailedTelemetry = true;
    options.CircuitBreakerOptions = new() { FailureThreshold = 3 };
})
.WithLogging()
.WithMetrics()
.WithCircuitBreaker();

var host = builder.Build();

// Usage in your services
public class MyService
{
    private readonly ITaskBatchProcessor _processor;
    
    public MyService(ITaskBatchProcessor processor)
    {
        _processor = processor;
    }
    
    public async Task ProcessDataAsync()
    {
        var tasks = new Dictionary<string, Func<CancellationToken, Task<object?>>>
        {
            ["API Call"] = async ct => await CallApiAsync(ct),
            ["DB Query"] = async ct => await QueryDatabaseAsync(ct)
        };
        
        await _processor.ProcessTasksAsync(tasks);
    }
}
```

## üìñ Comprehensive Examples

### Travel Dashboard (Real-world Scenario)

This example demonstrates fetching weather and activities data for multiple cities:

```csharp
using var processor = new TaskListProcessorEnhanced("Travel Dashboard", logger);
using var cts = new CancellationTokenSource(TimeSpan.FromMinutes(2));

var cities = new[] { "London", "Paris", "Tokyo", "New York" };
var taskFactories = new Dictionary<string, Func<CancellationToken, Task<object?>>>();

// Create tasks for each city
foreach (var city in cities)
{
    taskFactories[$"{city} Weather"] = ct => weatherService.GetWeatherAsync(city, ct);
    taskFactories[$"{city} Activities"] = ct => activitiesService.GetActivitiesAsync(city, ct);
}

// Execute and handle results
try 
{
    await processor.ProcessTasksAsync(taskFactories, cts.Token);
    
    // Group results by city
    var cityData = processor.TaskResults
        .GroupBy(r => r.Name.Split(' ')[0])
        .ToDictionary(g => g.Key, g => g.ToList());
    
    // Display results with rich formatting
    foreach (var (city, results) in cityData)
    {
        Console.WriteLine($"\nüåç {city}:");
        foreach (var result in results)
        {
            var status = result.IsSuccessful ? "‚úÖ" : "‚ùå";
            Console.WriteLine($"  {status} {result.Name.Split(' ')[1]}");
        }
    }
}
catch (OperationCanceledException)
{
    logger.LogWarning("Operation timed out after 2 minutes");
}
```

### Individual Task Execution

For scenarios requiring fine-grained control:

```csharp
// Execute a single task with full telemetry
var result = await processor.ExecuteTaskAsync(
    "Critical API Call", 
    httpClient.GetStringAsync("https://api.example.com/data"),
    cancellationToken);

if (result.IsSuccessful)
{
    var data = result.Data;
    logger.LogInformation("Received {DataLength} characters", data?.Length ?? 0);
}
else
{
    logger.LogError("API call failed: {Error}", result.ErrorMessage);
}
```

## üîß Advanced Usage

### Task Dependencies & Scheduling

```csharp
using TaskListProcessing.Models;
using TaskListProcessing.Scheduling;

// Configure with dependency resolution
var options = new TaskListProcessorOptions
{
    DependencyResolver = new TopologicalTaskDependencyResolver(),
    SchedulingStrategy = TaskSchedulingStrategy.Priority,
    MaxConcurrentTasks = Environment.ProcessorCount * 2
};

using var processor = new TaskListProcessorEnhanced("Advanced Tasks", logger, options);

// Define tasks with dependencies and priorities
var taskDefinitions = new[]
{
    new TaskDefinition
    {
        Name = "Initialize",
        Factory = async ct => await InitializeAsync(ct),
        Priority = TaskPriority.High
    },
    new TaskDefinition
    {
        Name = "Process Data",
        Factory = async ct => await ProcessDataAsync(ct),
        Dependencies = new[] { "Initialize" },
        Priority = TaskPriority.Medium
    },
    new TaskDefinition
    {
        Name = "Generate Report",
        Factory = async ct => await GenerateReportAsync(ct),
        Dependencies = new[] { "Process Data" },
        Priority = TaskPriority.Low
    }
};

await processor.ProcessTaskDefinitionsAsync(taskDefinitions);
```

### Circuit Breaker Configuration

```csharp
var options = new TaskListProcessorOptions
{
    CircuitBreakerOptions = new CircuitBreakerOptions
    {
        FailureThreshold = 5,
        RecoveryTimeout = TimeSpan.FromMinutes(2),
        MinimumThroughput = 10
    }
};

using var processor = new TaskListProcessorEnhanced("Resilient Tasks", logger, options);

// Tasks will automatically trigger circuit breaker on repeated failures
var taskFactories = new Dictionary<string, Func<CancellationToken, Task<object?>>>
{
    ["Resilient API"] = async ct => await CallExternalApiAsync(ct),
    ["Fallback Service"] = async ct => await CallFallbackServiceAsync(ct)
};

await processor.ProcessTasksAsync(taskFactories);

// Check circuit breaker status
var cbStats = processor.CircuitBreakerStats;
if (cbStats?.State == CircuitBreakerState.Open)
{
    Console.WriteLine($"Circuit breaker opened at {cbStats.OpenedAt}");
}
```

### Streaming Results

```csharp
using TaskListProcessing.Interfaces;

// Inject the stream processor
public class StreamingService
{
    private readonly ITaskStreamProcessor _streamProcessor;
    
    public StreamingService(ITaskStreamProcessor streamProcessor)
    {
        _streamProcessor = streamProcessor;
    }
    
    public async Task ProcessWithStreamingAsync()
    {
        var tasks = CreateLongRunningTasks();
        
        // Process results as they complete
        await foreach (var result in _streamProcessor.ProcessTasksStreamAsync(tasks))
        {
            Console.WriteLine($"Completed: {result.Name} - {result.IsSuccessful}");
            
            // Process result immediately without waiting for all tasks
            await HandleResultAsync(result);
        }
    }
}
```

### Health Monitoring

```csharp
var options = new TaskListProcessorOptions
{
    HealthCheckOptions = new HealthCheckOptions
    {
        MinSuccessRate = 0.8, // 80% success rate threshold
        MaxAverageExecutionTime = TimeSpan.FromSeconds(5),
        IncludeCircuitBreakerState = true
    }
};

using var processor = new TaskListProcessorEnhanced("Health Monitored", logger, options);

// After processing tasks
var healthResult = processor.PerformHealthCheck();
if (!healthResult.IsHealthy)
{
    Console.WriteLine($"Health check failed: {healthResult.Message}");
}

// Get detailed telemetry
var telemetrySummary = processor.GetTelemetrySummary();
Console.WriteLine($"Success rate: {telemetrySummary.SuccessRate:F1}%");
Console.WriteLine($"Average execution time: {telemetrySummary.AverageExecutionTime:F0}ms");
```

## üìä Performance & Telemetry

TaskListProcessor provides comprehensive telemetry out of the box:

### Built-in Metrics

```csharp
// Access telemetry after execution
var telemetry = processor.Telemetry;
var successRate = telemetry.Count(t => t.IsSuccessful) / (double)telemetry.Count * 100;
var averageTime = telemetry.Average(t => t.DurationMs);
var throughput = telemetry.Count / telemetry.Max(t => t.DurationMs) * 1000;

Console.WriteLine($"üìä Success Rate: {successRate:F1}%");
Console.WriteLine($"‚è±Ô∏è Average Time: {averageTime:F0}ms");
Console.WriteLine($"üöÄ Throughput: {throughput:F1} tasks/second");
```

### Sample Telemetry Output

```text
=== üìä TELEMETRY SUMMARY ===
üìà Total Tasks: 16
‚úÖ Successful: 13 (81.2%)
‚ùå Failed: 3
‚è±Ô∏è Average Time: 1,305ms
üèÉ Fastest: 157ms | üêå Slowest: 2,841ms
‚è∞ Total Execution Time: 20,884ms

=== üìã DETAILED TELEMETRY ===
‚úÖ Successful Tasks (sorted by execution time):
  üöÄ London Things To Do: 157ms
  üöÄ Dallas Things To Do: 339ms
  ‚ö° Chicago Things To Do: 557ms
  üèÉ London Weather: 1,242ms
  ...

‚ùå Failed Tasks:
  üí• Sydney Things To Do: ArgumentException after 807ms
  üí• Tokyo Things To Do: ArgumentException after 424ms
```

## üõ†Ô∏è API Reference

### Core Interfaces

| Interface | Description | Key Methods |
|-----------|-------------|-------------|
| `ITaskProcessor` | Single task execution | `ExecuteTaskAsync<T>()` |
| `ITaskBatchProcessor` | Batch processing | `ProcessTasksAsync()`, `ProcessTaskDefinitionsAsync()` |
| `ITaskStreamProcessor` | Streaming results | `ProcessTasksStreamAsync()` |
| `ITaskTelemetryProvider` | Telemetry & health | `GetTelemetrySummary()`, `PerformHealthCheck()` |

### TaskListProcessorEnhanced (Backward Compatible)

| Method | Description | Returns |
|--------|-------------|---------|
| `ProcessTasksAsync(taskFactories, progress, ct)` | Execute multiple tasks concurrently | `Task` |
| `ProcessTaskDefinitionsAsync(definitions, progress, ct)` | Execute tasks with dependencies | `Task` |
| `ExecuteTaskAsync<T>(name, task, ct)` | Execute single task with telemetry | `Task<EnhancedTaskResult<T>>` |
| `ProcessTasksStreamAsync(taskFactories, ct)` | Stream results as they complete | `IAsyncEnumerable<EnhancedTaskResult<object>>` |
| `GetTelemetrySummary()` | Get comprehensive telemetry | `TelemetrySummary` |
| `PerformHealthCheck()` | Check processor health | `HealthCheckResult` |

### Configuration Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `MaxConcurrentTasks` | `int` | `Environment.ProcessorCount * 2` | Maximum concurrent tasks |
| `DefaultTaskTimeout` | `TimeSpan` | `5 minutes` | Default task timeout |
| `EnableDetailedTelemetry` | `bool` | `true` | Enable comprehensive telemetry |
| `CircuitBreakerOptions` | `CircuitBreakerOptions?` | `null` | Circuit breaker configuration |
| `SchedulingStrategy` | `TaskSchedulingStrategy` | `FirstInFirstOut` | Task scheduling strategy |
| `DependencyResolver` | `ITaskDependencyResolver?` | `null` | Dependency resolution |

### Data Models

| Model | Description | Key Properties |
|-------|-------------|----------------|
| `EnhancedTaskResult<T>` | Task execution result | `Data`, `IsSuccessful`, `ErrorMessage`, `ErrorCategory` |
| `TaskTelemetry` | Telemetry data | `TaskName`, `ElapsedMilliseconds`, `IsSuccessful` |
| `TaskProgress` | Progress information | `CompletedTasks`, `TotalTasks`, `CurrentTask` |
| `TaskDefinition` | Task with metadata | `Name`, `Factory`, `Dependencies`, `Priority` |
| `CircuitBreakerStats` | Circuit breaker state | `State`, `FailureCount`, `OpenedAt` |
| `TelemetrySummary` | Aggregated telemetry | `SuccessRate`, `AverageExecutionTime`, `TotalTasks` |

## üß™ Testing

Run the comprehensive test suite:

```bash
# Run all tests
dotnet test

# Run with coverage
dotnet test --collect:"XPlat Code Coverage"

# Run specific test category
dotnet test --filter Category=Integration
```

### Test Coverage

- ‚úÖ **Unit Tests**: Core functionality and edge cases
- ‚úÖ **Integration Tests**: End-to-end scenarios  
- ‚úÖ **Performance Tests**: Throughput and latency validation
- ‚úÖ **Stress Tests**: High-concurrency scenarios

## üèóÔ∏è Project Structure

TaskListProcessor follows a clean architecture with clear separation of concerns:

```text
TaskListProcessor/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ TaskListProcessing/                    # Core library
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Core/                             # Core implementations
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskListProcessorEnhanced.cs  # Main orchestrator
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskProcessor.cs              # Single task execution
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskBatchProcessor.cs         # Batch processing
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskStreamProcessor.cs        # Streaming results
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TaskTelemetryProvider.cs      # Telemetry collection
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Interfaces/                       # Interface segregation
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ITaskProcessor.cs             # Single task interface
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ITaskBatchProcessor.cs        # Batch processing interface
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ITaskStreamProcessor.cs       # Streaming interface
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ITaskTelemetryProvider.cs     # Telemetry interface
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Extensions/                       # DI integration
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ServiceCollectionExtensions.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TaskProcessorBuilder.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Models/                           # Data models
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EnhancedTaskResult.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskDefinition.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskProgress.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ HealthCheckResult.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Scheduling/                       # Task scheduling
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskSchedulingStrategy.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AdvancedTaskScheduler.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TopologicalTaskDependencyResolver.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CircuitBreaker/                   # Circuit breaker pattern
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CircuitBreaker.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CircuitBreakerOptions.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoadBalancing/                    # Load balancing
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoadBalancingStrategy.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LoadBalancingTaskDistributor.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Telemetry/                        # Telemetry & metrics
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskTelemetry.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TelemetrySummary.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SchedulerStats.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Options/                          # Configuration
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskListProcessorOptions.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CircuitBreakerOptions.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ HealthCheckOptions.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Decorators/                       # Cross-cutting concerns
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoggingTaskProcessorDecorator.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ MetricsTaskProcessorDecorator.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Testing/                          # Test utilities
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TaskListProcessorTestHelpers.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Utilities/                        # Helper classes
‚îÇ   ‚îú‚îÄ‚îÄ CityWeatherService/                   # Example service
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ WeatherService.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CityWeatherService.csproj
‚îÇ   ‚îî‚îÄ‚îÄ CityThingsToDo/                       # Example service
‚îÇ       ‚îú‚îÄ‚îÄ CityThingsToDoService.cs
‚îÇ       ‚îî‚îÄ‚îÄ CityThingsToDo.csproj
‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îî‚îÄ‚îÄ TaskListProcessor.Console/            # Demo application
‚îÇ       ‚îú‚îÄ‚îÄ Program.cs
‚îÇ       ‚îî‚îÄ‚îÄ Utilities/
‚îÇ           ‚îú‚îÄ‚îÄ AppConfiguration.cs
‚îÇ           ‚îú‚îÄ‚îÄ OutputFormatter.cs
‚îÇ           ‚îú‚îÄ‚îÄ ResultsDisplay.cs
‚îÇ           ‚îî‚îÄ‚îÄ TelemetryDisplay.cs
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ TaskListProcessing.Tests/             # Core library tests
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ InterfaceSegregationTests.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TaskListProcessing.Tests.csproj
‚îÇ   ‚îú‚îÄ‚îÄ CityWeatherService.Tests/             # Service tests
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ WeatherServiceTests.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CityWeatherService.Tests.csproj
‚îÇ   ‚îî‚îÄ‚îÄ CityThingsToDo.Tests/                 # Service tests
‚îÇ       ‚îú‚îÄ‚îÄ CityThingsToDoServiceTests.cs
‚îÇ       ‚îî‚îÄ‚îÄ CityThingsToDo.Tests.csproj
‚îú‚îÄ‚îÄ docs/                                     # Documentation
‚îÇ   ‚îú‚îÄ‚îÄ PHASE1_README.md                      # Phase 1 features
‚îÇ   ‚îú‚îÄ‚îÄ MIGRATION_GUIDE.md                    # Migration guide
‚îÇ   ‚îî‚îÄ‚îÄ CLEANUP_SUMMARY.md                    # Cleanup notes
‚îî‚îÄ‚îÄ README.md                                 # This file
```

### Key Architecture Principles

- **Interface Segregation**: Clean, focused interfaces for different scenarios
- **Dependency Injection**: Native .NET DI with fluent configuration
- **Single Responsibility**: Each component has a clear, focused purpose
- **Extensibility**: Decorator pattern for cross-cutting concerns
- **Testability**: Mockable interfaces and comprehensive test coverage

## üîÑ Migration Guide

### From Legacy Processors to Modern Interfaces

**Recommended Migration Path:**

1. **Migrate to Dependency Injection** (Recommended)

```csharp
// Old approach
var processor = new TaskListProcessorEnhanced("Tasks", logger);

// New approach
services.AddTaskListProcessor(options =>
{
    options.MaxConcurrentTasks = 10;
    options.EnableDetailedTelemetry = true;
})
.WithLogging()
.WithMetrics();

// In your service
public class MyService
{
    private readonly ITaskBatchProcessor _processor;
    public MyService(ITaskBatchProcessor processor) => _processor = processor;
}
```

2. **Direct Interface Usage** (Alternative)

```csharp
// Single task processing
var taskProcessor = new TaskProcessor("SingleTasks", logger);
var result = await taskProcessor.ExecuteTaskAsync("task", someTask);

// Batch processing
var batchProcessor = new TaskBatchProcessor("BatchTasks", logger);
await batchProcessor.ProcessTasksAsync(taskFactories);

// Streaming results
var streamProcessor = new TaskStreamProcessor("StreamTasks", logger);
await foreach (var result in streamProcessor.ProcessTasksStreamAsync(tasks))
{
    // Process results as they complete
}
```

3. **Backward Compatibility** (For existing code)

```csharp
// TaskListProcessorEnhanced still works with all existing features
using var processor = new TaskListProcessorEnhanced("Legacy", logger);
await processor.ProcessTasksAsync(taskFactories);
```

### New Features in Current Version

- **Interface Segregation**: Clean, focused interfaces for different scenarios
- **Dependency Injection**: Native .NET DI integration with fluent configuration
- **Task Dependencies**: Topological sorting and dependency resolution
- **Circuit Breaker**: Automatic failure detection and recovery
- **Advanced Scheduling**: Priority-based, dependency-aware task execution
- **Streaming Results**: Real-time result processing via async enumerables
- **Enhanced Telemetry**: OpenTelemetry integration and health monitoring
- **Memory Optimization**: Object pooling and efficient resource management

### Breaking Changes

1. **Namespace Changes**: Main classes moved to `TaskListProcessing.Core`
2. **Interface Requirements**: New interfaces may require additional dependencies
3. **Configuration Options**: Enhanced options structure with validation
4. **Result Types**: Enhanced error categorization and telemetry data

## ü§ù Contributing

We welcome contributions! Here's how to get started:

### Development Setup

```bash
# Clone and setup
git clone https://github.com/markhazleton/TaskListProcessor.git
cd TaskListProcessor

# Restore dependencies
dotnet restore

# Build solution  
dotnet build

# Run tests
dotnet test
```

### Contribution Guidelines

1. **üç¥ Fork** the repository
2. **üåø Create** a feature branch (`git checkout -b feature/amazing-feature`)
3. **‚ú® Make** your changes with tests
4. **‚úÖ Verify** all tests pass (`dotnet test`)
5. **üìù Commit** your changes (`git commit -m 'Add amazing feature'`)
6. **üöÄ Push** to the branch (`git push origin feature/amazing-feature`)
7. **üéØ Open** a Pull Request

### Code Standards

- Follow [C# Coding Conventions](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions)
- Add XML documentation for public APIs
- Include unit tests for new features
- Maintain backward compatibility when possible

## üìú License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

```text
MIT License

Copyright (c) 2024 Mark Hazleton

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
```

## üîó Resources

### üìö Documentation & Articles

- [üìñ Phase 1 Features Guide](docs/PHASE1_README.md) - Interface segregation and dependency injection
- [üìù Migration Guide](docs/MIGRATION_GUIDE.md) - Detailed migration instructions
- [üîÑ Cleanup Summary](docs/CLEANUP_SUMMARY.md) - Recent improvements and changes
- [üåê Complete Technical Article](https://markhazleton.com/task-list-processor.html) - Deep dive into architecture and patterns
- [ÔøΩ Best Practices Guide](https://markhazleton.com/async-best-practices.html) - Async programming patterns

### üéØ Examples & Demos

- [üñ•Ô∏è Console Demo](examples/TaskListProcessor.Console/) - Interactive demonstration
- [üåê Web Dashboard Example](examples/TaskListProcessor.Web/) - ASP.NET Core integration
- [üìä Performance Benchmarks](benchmarks/) - Performance analysis and comparisons

### üë• Community & Support

- [üêõ Report Issues](https://github.com/markhazleton/TaskListProcessor/issues) - Bug reports and feature requests
- [üí¨ Discussions](https://github.com/markhazleton/TaskListProcessor/discussions) - Community support and Q&A
- [üìß Contact Mark](mailto:mark@markhazleton.com) - Direct contact for enterprise support

### üîó Mark Hazleton Online

- [üåê Website](https://markhazleton.com) - Blog and technical articles
- [üíº LinkedIn](https://www.linkedin.com/in/markhazleton) - Professional network
- [üì∫ YouTube](https://www.youtube.com/@MarkHazleton) - Technical tutorials and demos
- [üì∏ Instagram](https://www.instagram.com/markhazleton/) - Behind the scenes content

---

## üöÄ Get Started Today

Ready to supercharge your async operations? Get started with TaskListProcessor:

```bash
git clone https://github.com/markhazleton/TaskListProcessor.git
cd TaskListProcessor
dotnet run --project examples/TaskListProcessor.Console
```

**See it in action with our interactive demo that showcases:**

- üåç Multi-city travel data aggregation with dependency resolution
- ‚ö° Concurrent API calls with circuit breaker protection
- üìä Rich telemetry with OpenTelemetry integration
- üéØ Type-safe result processing with error categorization
- ‚è±Ô∏è Advanced scheduling with priority-based execution
- üîÑ Streaming results via async enumerables
- üèóÔ∏è Dependency injection with decorator pattern support

*Built with ‚ù§Ô∏è by [Mark Hazleton](https://markhazleton.com) ‚Ä¢ Follow for more .NET content and best practices*

---

## üìà Project Stats

![GitHub stars](https://img.shields.io/github/stars/markhazleton/TaskListProcessor?style=social)
![GitHub forks](https://img.shields.io/github/forks/markhazleton/TaskListProcessor?style=social)
![GitHub issues](https://img.shields.io/github/issues/markhazleton/TaskListProcessor)
![GitHub last commit](https://img.shields.io/github/last-commit/markhazleton/TaskListProcessor)

*‚≠ê If this project helped you, please consider giving it a star!*
